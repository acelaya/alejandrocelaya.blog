import { format, parse } from 'date-fns';
import type { TaxonomiesType } from '../components/types';
import { getCollection, z } from 'astro:content';

export const PAGE_SIZE = 5;

export const postMetaSchema = z.object({
  title: z.string(),
  categories: z.array(z.string()),
  tags: z.array(z.string())
})

export type PostMeta = z.infer<typeof postMetaSchema>;

export interface Post {
  id: string;
  slug: string;
  url: string;
  date: string;
  formattedDate: string;
  data: PostMeta;
}

export const getAllPosts = () => getCollection('posts').then(
  (posts) => posts.reverse().map(
    ({ slug, ...rest }) => {
      const [year, month, day, ...restOfSlug] = slug.split('-');
      const url = `/${year}/${month}/${day}/${restOfSlug.join('-')}/`;
      const date = `${year}-${month}-${day}`;
      const formattedDate = format(parse(date, 'y-M-d', new Date()), 'dd MMMM y');

      return {
        slug,
        url,
        date,
        formattedDate,
        ...rest,
      };
    },
  ),
);

export const getLatestPosts = async () => {
  const posts = await getAllPosts();
  return posts.slice(0, PAGE_SIZE);
};

export const summaryForPost = (post: Post) => import(/* @vite-ignore */`../content/posts/${post.id}`).then(
  // The summary prop is generated by rehype's mdx-post-summary-plugin
  ({ summary }) => summary,
);

// const filterByCategoryOrTag = (category?: string, tag?: string) => (post: Post) => {
//   if (category) {
//     return post.categories.includes(category);
//   }
//
//   if (tag) {
//     return post.tags.includes(tag);
//   }
//
//   return true;
// };

// export const listTaxonomies = async (prop: TaxonomiesType): Promise<string[]> => {
//   const posts = await listPosts();
//   const taxonomies = posts.map((post) => post[prop]).flat();
//
//   return [ ...new Set(taxonomies) ].sort((a, b) => a < b ? -1 : 1);
// }
